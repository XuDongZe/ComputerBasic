## 操作系统的运行环境与运行机制
* OS中断/异常机制 -> OS/硬件界面
* OS系统调用机制 -> 应用程序/OS界面

### CPU -> 中央处理器
* 硬件构成：
	运算器、控制器、一系列寄存器、高速缓存
* 寄存器分类：
	* 用户可见寄存器：暴露给用户（程序/编译器）的寄存器
	* 控制和状态寄存器：用户不可见，用于控制处理器，在某种特权级别下可以访问、修改
	* PC、IR、PSW（程序状态字）

### 保护与控制机制
* 为何需要保护机制：这是由OS的特征决定的，并发、共享
	* 不同用户程序之间
	* 用户程序与系统程序之间
* 需要硬件提供基本机制：
	* CPU具有不同状态，指令也具有不同的特权级别。处于不同状态的CPU可以执行不同特权级别的指令。一般非为用户态/内核态两种，而对应的指令分为特权指令和非特权指令。
	* 在硬件和指令层次上，可以在指令执行过程中检查特权级别。只有等于或者高于要处理的代码的特权级别才可以访问该代码。例如x86处理器在装载中断处理程序时，用到的中断描述符、段选择符中都包含特权级字段，只有当前特权级>=该字段指示的特权级别才可以访问。
	
### CPU状态转换
* 操作系统需要两种CPU状态：
	* 内核态 ： 执行OS程序
	* 用户态 ： 执行用户程序
* 据此划分指令：
	* 特权指令 ： 只能由OS使用（启动IO，内存清零，修改程序状态字、设置时钟、允许/禁止中断、停机、）
	* 非特权指令
* 在PSW中专门设置一位，指示当前CPU状态。
* 用户态 -> 内核态，从而使用OS服务
	* 唯一途径：中断/异常/陷入机制。
	* 一条特殊指令：陷入指令（访管指令：访问管理态），提供给用户程序的接口，使OS陷入内核态从而调用OS的功能。（int trap syscall等）。由于中断/异常是不可预见的，故而 陷入指令 是唯一的可以可编程的 陷入OS的指令。
* 内核态 -> 用户态，返回用户态
	* 设置PSW

### 中断/异常机制基本概念
* 中断之于OS，类似于发动机之于汽车。OS可以说是事件驱动的，或者是 中断驱动的。
* 一般上说，中断/异常处理过程中的CPU控制流：
	* 中断发生后，CPU暂停正在执行的程序，保留现场
	* CPU转而执行中断处理程序
	* 处理完毕后CPU返回断点，继续执行
* 中断特点
	* 随机发生
	* 软硬件协作处理
	* 可恢复
* 为何引入中断？
	* 中断刚开始出现时，只是单纯的为了支持CPU和设备之间的并行操作。CPU将数据和控制信号给与IO设备后，设备和CPU就可独立工作：设备去处理诸如打印的操作，CPU处理下一个被调度的进程；当设备完成后，发出中断信号向CPU报告该作业已经完成。为了了解中断的作用，我们可以考察在中断出现之前，这个问题是怎样解决的。如现在有打印机，支持多进程的CPU，进程有打印进程A 和 数据处理进程B。假设现在在CPU中运行的为进程A，那么怎样确定A进程完毕呢？
		* 轮询法：每隔一个固定时间CPU询问打印进程是否完毕
		* 中断法：当打印进程完毕后主动向CPU发出中断信号。
	* 后来我们发现，除了 捕获设备的中断请求，基于中断机制我们可以做很多事情：
		* 向OS发出服务请求 -> 系统调用
		* 解决运行时异常/错误 -> 异常处理
* 为何引入异常？
	* 指令执行时出现问题。（算术溢出、除零、访问地址越界）

### 要实现上述的CPU控制流的转移，我们要解决的问题：
* 如何检测中断发生？
* CPU工作状态由那些信息描述？这些信息保存在哪些寄存器或者堆栈中？CPU的状态切换是如何实现的？
* 中断发生时有哪些现场数据需要保护？为什么要保护这些信息？又要将其保存到哪里？在这些保护工作中，哪些是由硬件完成的，哪些由软件完成？
* 如何找到中断处理程序的入口地址（第一条指令的地址）？
* 如何使CPU转而处理中断处理程序？
* 中断处理程序处理完毕之后如何通知CPU？CPU应该返回到哪里（指令级）？CPU又是如何返回断点？
* 在控制转移过程中特权级别发生改变该如何处理？

### 中断/异常机制工作原理： 捕获 -> 切换上下文 -> 具体中断处理(软) -> 恢复上下文
* 硬件：中断/异常响应
	* 如何捕获呢？答案是在每一个指令执行时收集和检查，这是指令级的。CPU中设置有一个中断寄存器来存储收集到的中断/异常信息。从具体实现来看，假设我们使用MIPS指令集，并实现了5级流水线（取值、译码、执行、访存、回写）的CPU。在指令可能产生中断的每一个周期（实际上是前四个周期：取指、译码、执行、访存），CPU都会自动收集该中断/异常信息（自动是指在硬件实现），并将中断信息按类型编码保存至中断寄存器。在每条指令执行的最后一个周期（回写：此时该指令即将完成，不会由于这条指令出现中断/异常）CPU扫描中断寄存器，查看是否有中断信号。
	* 捕获到中断信号后，硬件将完成一些工作，为软件的处理过程准备环境：首先将CPU切换到内核态；在系统栈中保存被中断程序的重要上下文环境：PC & PSW；根据中断码查询中断向量表，将PC设置为处理程序的入口地址。这些都完成后，在下一个时钟周期，CPU将转移到中断处理程序。
	* 当终端处理结束后，又是如何恢复的呢？ 首先CPU需要一个信号指示该处理过程结束了，这由中断返回指令给出，这通常是终端处理程序的最后一条指令；那么从系统栈中恢复上下文：PC & PSW（或许还包括任务状态段等重要的CPU寄存器），则下一个CPU周期，CPU将从断点处继续执行。
* 软件：中断/异常处理
	* 在设计操作系统时，将为每一类中断/异常事件事先编好相应的处理程序，并设置好中断向量表。
	* 中断处理程序获得CPU控制权之后，首先，保存相关寄存器信息，这是将系统栈相应数据拷贝到中断处理程序进程栈中。
	* 分析中断/异常的具体原因
	* 执行对应的处理功能
	* 发出中断返回指令
* 中断向量表：每一行都是一个中断向量，一个中断向量实际上是一个内存单位。其内容取决于OS所处的模式是实模式还是保护模式。在实模式下，用于存放中断处理程序的入口地址和程序运行时所需的处理机状态字；在保护模式下用于存放中断描述符。中断向量表(IDT)是一段连续的内存空间，其起始地址由中断向量表寄存器(IDTR)记录。CPU按中断码查询中断向量表，类似于在C语言中使用下标查询一个数组。不论处于实模式还是处于保护模式，我们都可以依赖[IDT+中断码]得到终端处理程序的入口地址。
* 总结：大部分工作，包括中断/异常的捕获、上下文切换和恢复（寄存器、系统堆栈、CPU状态）都是硬件完成的，我们称之为自动处理；只有具体的中断处理是由软件（代码）完成的，代码在处理中断时和一般程序（hello world）没有什么不同。

### x86处理器中的中断/异常机制
* 中断分为可屏蔽中断和不可屏蔽中断。
* 中断控制器（PIC或APIC）
	* 负责将硬件的中断信号转换为中断向量，并引发CPU中断
* 实模式：中断向量表
	* 存放中断服务程序的入口地址
		* 入口地址 = 段地址 << 4 + 偏移地址
		* 没有CPU状态之分
* 保护模式：中断描述符
	* 采用门描述符 描述一个中断
	* 四种类型门描述符（数据结构）
		* 任务门
		* 中断门：在通过中断门之后会自动禁止中断，也就是禁止中断的嵌套。
		* 陷阱门：与中断门类似，但是通过一个陷阱门之后不会禁止中断。
		* 调用门
* x86处理器对中断的支持
	* 确定与中断有关的向量i
	* 通过IDTR寄存器找到中断描述符表(IDT)的起始地址，并通过中断向量i找到中断描述符（IDT[i],即IDT表的第i项）
	* 中断描述符中包含有段内偏移和段选择符，通过段选择符的idx字段和GDTR得到的GDT的起始地址，在GDT中找到段描述符；段描述符中包含有中断处理程序的段基址。
	* 现在我们找到了段基址（IDTR IDT[i].selector -> GDTR & GDT[selector.index]）和段内偏移（IDTR -> IDT[i] -> offset），那么真实地址为：段基址 << 4 + 段内偏移。
	* 特权级检查：若有特权级的变化，则进行堆栈切换（使用与新的特权级相关的栈）
	* 硬件压栈，保存上下文环境；若异常产生了硬件出错码，也将其保存在栈中。
	* 若为中断门，清空IF位，也就是在中断过程中禁止中断嵌套。
	* 执行中断处理程序，处理完毕后由中断返回指令返回断点

### OS系统调用机制 -> OS/应用程序界面
* 系统调用机制：OS向用户提供的唯一接口，是用户在编程时可以调用的操作系统功能
* 使CPU状态从用户态陷入到内核态。
* 每种操作系统都提供不同的系统调用：
	* 进程控制类
	* 进程通信类
	* 文件使用类
	* 目录操作
	* 设备管理
	* 信息维护
* 系统调用、库函数、API、内核函数
	* 系统调用与C库函数/API：应用程序可以直接调用系统调用，但更多的是通过调用C库函数/API接口来间接地使用系统调用。
	* 系统调用与内核函数：内核函数有些是不开放给用户使用的，而开放的那些包装为系统调用？？？？
* 系统调用机制设计
	* 需要中断/异常机制支持
	* 需要一条特殊的指令：引发异常，完成用户态到内核态的切换
	* 需要事先确定系统调用的编号和参数
	* 需要系统调用表，存放系统调用服务例程的入口地址，这是系统初始化时就设计好的

### 系统调用参数传递问题：如何实现用户程序的参数传递给内核
* 在用户程序之间的参数传递一般是通过内存堆栈传递，但是用户程序和内核之间由于CPU处于不同的状态，当前堆栈指针也会切换，所以不能使用这种方式。
* 由陷入指令自带参数：指令本身长度有限，且还要携带系统调用功能号，只能自带有限的参数
* 通用寄存器传递参数：OS和用户程序都能访问，但寄存器的个数会限制传递参数的数量。这是通常使用的。
```c
#include <unistd.h>
int main() {
	char string[5] = {'H', 'e', 'l', 'l', 'o','!','\n'};
	write(1, string, 7);
	return 0;
}
```

* 对应的asm代码示意
```asm
.section .data
output:
	.ascii "hello!\n"
output_end:
	.equ len, output_end - output

.section .text
.globl _start

_start:
	movl $4, %eax #eax存放系统调用号
	movl $1, %ebx	#以下3条movl将write参数保存至寄存器
	movl $output, %ecx
	movl $len, %edx
	int $0x80 	#引发系统调用

end:
movl $1, %eax	#1系统调用 用于 return返回
movl $0, %ebx
int $0x80
```
* 在内存中开辟专用堆栈区：这些堆栈区不会随CPU状态切换而自动切换。

### 系统调用的执行过程
* 系统调用都具有同一个入口：int $0x80）
* 系统调用总入口程序（这是该程序代码做的事情）：保存现场；将参数保存在内核堆栈里；通过查找系统调用表（这是逻辑实现的），将控制权转交给相应的系统调用处理例程或者内核函数
* 执行系统调用例程
* 恢复现场，返回用户程序
* 我们可以将系统调用看作一个特殊的中断，它的中端码只有一个（不论哪个系统调用）。系统调用总入口程序看作该中断的中断处理程序：该程序包含有一个参数，指示了由该程序的哪一个子例程具体处理该系统调用。这个参数就是即系统调用号。
















