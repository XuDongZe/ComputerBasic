##操作系统概述

###操作系统做了什么
首先我们分析一段C代码，然后显示地（不解释为什么要这样做）揭示OS在该代码执行过程中做了哪些事情。
```c
#include <stdio.h>
int mian(int argc, char* argv[]) {
	printf("hello world\n");
	return 0;
}
```

* 用户如何告知OS我现在要执行helloworld程序？实际上这属于OS的用户接口，一般而言OS会提供命令行交互接口，如果OS支持图形用户界面，我们也可以通过对应的图形界面方式执行一个helloworld程序。
* OS：
	* 找到helloworld程序的相关信息，检查文件类是否为可执行程序。
	* 通过程序首部信息，确定代码和数据在可执行文件中的位置并计算出对应的磁盘块地址（这与可执行文件的文件格式有关：Windows：PE & Linux：LEF）
	* 创建一个新的进程并将helloworld可执行文件映射到该进程结构，即由该进程执行helloworld程序。
	* OS将控制权交由进程调度程序。当调度程序选中该进程时，为helloworld程序设置CPU上下文环境，并将CP跳到程序开始处，那么下一个CPU周期将执行该程序的第一条指令。
	* 在执行第一条指令时，发生缺页异常，将控制权交给OS。因为此时helloworld的代码和数据均还没有读入内存。OS分配一页物理内存，并将代码从磁盘读入内存，继续执行helloworld。当程序较大时，缺页异常将多次发生并处理。
	* 执行puts函数（系统调用），在显示器上显示字符串。
	* OS找到字符串将要送往的设备（进程），并将字符串交由该进程。
	* 控制设备的进程告知设备的窗口系统将要显示字符串，窗口系统确定该操作合法，将字符串转换为像素，将像素写入设备的存储映像区。
	* 硬件将像素转换成显示器可以接受的一组控制/数据 信号。显示器解释该信号，激发液晶屏。
	* over。helloworld显示在了液晶屏上。

### 操作系统的定义
* 计算机系统中的一个系统软件

### 操作系统的作用
* 资源管理者
* 为用户提供各种服务：命令接口、编程接口
* 对硬件机器的扩展：用户面对的不是复杂琐碎的硬件接口，而是建立在硬件之上的OS。或许OS会暴露一些直接操作硬件的接口给用户，但大部分的硬件对用户是不可见的。 

###资源管理者
* 资源的管理者
	* 硬件资源：CPU、内存、设备（IO、磁盘、网卡等）
	* 软件资源：文件、
* 如何管理资源
	* 数据结构：跟踪记录资源的使用状况
		* 哪些资源空闲、分配给谁、允许使用多长时间
	* 算法：资源分配策略
		* 静态分配：在进程执行前就将其所需要的所有资源就已经分配好 -> 资源浪费。
		* 动态分配：i.e. BitMap
	* 资源的分配和回收
	* 提高资源利用率
	* 协调多个进程对资源的请求
* 资源管理的基本功能
	* 进程/线程管理
	* 存储管理
	* 文件管理
	* 设备管理
	* 用户接口

### 操作系统的特征
* 并发：只处理多个同时性活动的能力
* 共享：操作系统与多个用户的程序共同使用计算机系统中的资源（共享有限的系统资源），资源在一段时间内交替的被多个进程使用，分为 护持共享与同时共享。
	* 互斥共享：打印机
	* 同时共享：可重入代码、磁盘文件
* 虚拟：一个物理实体映射为若干个对应的逻辑实体 -> 通过分时或者分空间
	* 提高资源利用率
	* CPU -> 每个进程一个“虚拟”处理器
	* 存储器 -> 每个进程都有自己独立的虚拟地址空间(代码+数据+堆栈)
	* 显示设备 -> 多窗口
* 随机：必须随时对以不可预测的次序发生的事件进行响应
	* 进程的运行速度无法预知
	* 很难重现系统在某个时刻的状态，调试OS极为困难

### 传统操作系统的分类（目标 +工作方式）
* 批处理操作系统
	* 工作方式：
		* 用户将作业交给系统操作员
		* 操作员将许多用户的作业组成一批作业，输入到计算机系统中，形成一个连续的作业流
		* 启动操作系统，系统自动、依次执行每个作业
		* 由操作员将作业结果交给用户
	* 用户不干预作业的执行，由代理（操作员）执行
	* 目标：增加吞吐量
	* 问题：慢速的输入输出直接由主机完成，输入输出时，CPU处于等待状态
	* 解决方案：
		* 卫星机，使用其他计算机做输入输出的处理（这是说我们需要两台专门的计算机去做输入机和输出机。主机的输入输出只面向卫星机：直接使用输入机的处理结果，将中间结果送往输出机即可），工作过程中作业需要脱离输入机到主机执行、脱离主机到输出机输出，所以称作“脱机”。
		* 考虑一个打印任务来体验卫星机的作用。在打印过程中，输入机可能需要从外设按序读入该批文本（这可能需要需要人工键入或者扫描仪扫描等很慢的操作），主机可能使用机器学习算法分析该文本并将分析结果以文本形式传送给输出机；输出机则负责将分析结果打印出来（打印机的打印过程直到最后一页纸打印完毕才完成，如果你在打印店等待你的100+页论文打印3份，同时要求你在打印机打印过程只能等着而不能开始下一次打印，那么打印店老板会崩溃的相信我😂）
		* 单道/多道批处理：在主机上一次性输入多少作业
* 分时操作系统
* 实时操作系统
* 网络操作系统
* 分布式操作系统
* 嵌入式操作系统

### Spooling技术（假脱机）：批处理
* 利用磁盘做缓冲（输入缓冲区替换输入机、输出缓冲区替换输出机），将输入、计算、输出合并到一台计算机中进行，仍然处理了输入速率与CPU处理速率的矛盾；使IO和计算真正并行。
* 工作方式：
	* 将作业加载到磁盘上的输入井（磁盘上的一块存储空间）
	* 通过某种调度算法调度几个合理的作业，将其从输入井加载到内存
	* 作业执行，将执行结果输出到磁盘的输出井
	* 将输出井上的对应结果送到打印机
* 现代计算机系统的打印过程通常采用Spooling技术。
	* 当打印纸还没有打印上内容时，从计算机系统的角度看可能打印进程已经结束了。在此时你就可以关闭该要打印的word文件，因为OS已经将打印内容发送到一个请求队列，一旦发送完毕，则OS认为该打印进程结束。

### 问题？
* Spooling技术和多进程/多线程？？？
* 单道/多道批处理？？？？