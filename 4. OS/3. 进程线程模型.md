## 进程模型

### 多道程序设计技术
* 基本思想：允许多个程序同时进入内存并运行，目的是为了提高系统效率
* 实现方式：多个程序按照某种策略轮流获得资源（CPU和内存）。需要内存上支持多个程序的数据、代码、状态的存储；CPU上支持环境上下文的切换。
* 并发环境：在一段时间内，单CPU上有两个或以上的程序同时处于开始运行但尚未结束的状态，并且次序是无法预测的。

### 进程定义：刻画并发环境下的并发程序
* Process：是具有独立功能的程序关于某个数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位。
* 首先，进程是程序的一次执行过程，也就是说同一程序的几次不同的执行过程将生成不同的进程；然后，进程是正在运行程序的抽象，它包含了程序的代码、数据，还包含了此时的CPU状态、内存分配状态等和进程相关的动态信息；最后，系统资源（内存、CPU、地址空间等）是以进程为单位分配的，OS通过将CPU控制权交给某个进程实现进程的调度。

### 描述进程的唯一数据结构：进程控制块PCB（包含控制和管理进程的所有信息）
* PCB是什么？PCB，进程控制块，又称为进程描述符，是OS用于管理和控制进程的一个专门的数据结构。PCB记录进程的各种属性，并且应当可以描述进程的动态变化。PCB是OS感知进程的唯一标志，没产生一个新的进程，OS就为其生成一个PCB。它们是一一对应的。
* 进程表：为了管理进程，OS中当前所有进程的PCB集合。进程表的开始地址在内存中是固定的，这应当在OS设计时被确定；进程表的大小也是固定的 -> 决定了一个OS中能够运行的进程的最大数量，称为该操作系统的并发度。
* PCB里面应该有什么？
* 进程描述信息：进程标识符、进程名、用户标识符、进程间关系（子进程、父进程、兄弟进程）
* 进程控制信息：进程单签状态、优先级、代码执行入口地址、可执行文件的磁盘位置、进程相关队列、运行统计信息（执行时间、页面置换）进程间通信和同步信息
* 占用资源：打开文件列表、地址空间信息
* CPU现场信息：
	* 寄存器值（通用寄存器、PC、PSW、栈指针）
	* 指向该进程页面的指针
* 进程应该有哪些属性？在OS中一个进程的生命周期是怎样的？

### 进程的三种基本状态以及状态转换
* 运行态：占有CPU，正在CPU上运行
* 就绪态：已经具备运行条件，仅仅由于没有空闲的CPU二暂时不能运行
* 等待态：因等待某一事件（读文件等）而暂时不能运行
；又称为阻塞态、封锁态、睡眠态。

### 进程队列
* 每一类进程建立一个或者多个队列，队列元素为PCB
* 进程状态的改变实际上就是PCB从一个队列进入另一个队列的过程
* 就绪队列可以是一个队列，也可以是多个（优先级调度算法中，按优先级组织多个就绪队列）
* 等待队列通常按等待原因组织为多个，当进程状态由运行 -> 阻塞态时，将PCB由运行态队列出队，并按照等待原因（这将抽象为一个等待因子）链接到相应的等待队列中；运行态队列在单CPU中只有一个。

### 进程控制
* 进程控制操作：完成进程个状态之间的转换，由特定功能的原语完成。包括
* 原语：一种原子操作，完成某种特定功能的一段程序，在执行过程中不可中断，这可以通过OS禁止中断来完成。
* 进程创建原语：fork/exec CreateProcess
	* 分配PID，PCB
	* 为进程分配地址空间，虚拟地址空间，而非真正分配内存
	* 初始化PCB
	* 设置相应的队列指针：i.e.将新进程加入就绪队列中
* 进程的撤销：结束进程 exit、 TerminateProcess
	* 回收进程所占有的资源：关闭打开文件、断开网络连接、回收分配的内存等。
	* 回收PCB
* 进程阻塞 ：wait WaitForSingleObject
	* 处于运行状态的进程，在运行过程中等待某一事件发生（等待键盘输入、等待磁盘IO、等待其他进程的消息等），当该事件未发生时，该进程自己执行阻塞原语，使自己的状态变为阻塞态。

### 









































