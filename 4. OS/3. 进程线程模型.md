## 进程模型

### 多道程序设计技术
* 基本思想：允许多个程序同时进入内存并运行，目的是为了提高系统效率
* 实现方式：多个程序按照某种策略轮流获得资源（CPU和内存）。需要内存上支持多个程序的数据、代码、状态的存储；CPU上支持环境上下文的切换。
* 并发环境：在一段时间内，单CPU上有两个或以上的程序同时处于开始运行但尚未结束的状态，并且次序是无法预测的。

### 进程定义：刻画并发环境下的并发程序
* Process：是具有独立功能的程序关于某个数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位。
* 首先，进程是程序的一次执行过程，也就是说同一程序的几次不同的执行过程将生成不同的进程；然后，进程是正在运行程序的抽象，它包含了程序的代码、数据，还包含了此时的CPU状态、内存分配状态等和进程相关的动态信息；最后，系统资源（内存、CPU、地址空间等）是以进程为单位分配的，OS通过将CPU控制权交给某个进程实现进程的调度。

### 描述进程的唯一数据结构：进程控制块PCB（包含控制和管理进程的所有信息）
* PCB是什么？PCB，进程控制块，又称为进程描述符，是OS用于管理和控制进程的一个专门的数据结构。PCB记录进程的各种属性，并且应当可以描述进程的动态变化。PCB是OS感知进程的唯一标志，没产生一个新的进程，OS就为其生成一个PCB。它们是一一对应的。
* 进程表：为了管理进程，OS中当前所有进程的PCB集合。进程表的开始地址在内存中是固定的，这应当在OS设计时被确定；进程表的大小也是固定的 -> 决定了一个OS中能够运行的进程的最大数量，称为该操作系统的并发度。
* PCB里面应该有什么？
* 进程描述信息：进程标识符、进程名、用户标识符、进程间关系（子进程、父进程、兄弟进程）
* 进程控制信息：进程单签状态、优先级、代码执行入口地址、可执行文件的磁盘位置、进程相关队列、运行统计信息（执行时间、页面置换）进程间通信和同步信息
* 占用资源：打开文件列表、地址空间信息
* CPU现场信息：
	* 寄存器值（通用寄存器、PC、PSW、栈指针）
	* 指向该进程页面的指针
* 进程应该有哪些属性？在OS中一个进程的生命周期是怎样的？

### 进程的三种基本状态
* 运行态：占有CPU，正在CPU上运行
* 就绪态：已经具备运行条件，仅仅由于没有空闲的CPU二暂时不能运行
* 等待态：因等待某一事件（读文件等）而暂时不能运行
；又称为阻塞态、封锁态、睡眠态。

### 三状态模型状态转换
* 创建  初始化 -> 就绪态；
* 调度  就绪态 -> 运行态；
* 超时 	运行态 -> 就绪态
* 阻塞	运行态 -> 阻塞态（等待某一事件：IO结果/另一进程的消息）
* 唤醒 	阻塞态 -> 就绪态（等待的事件发生）

### 七状态模型
* 创建、就绪、运行、阻塞、死亡、挂起就绪、挂起阻塞
* 挂起是什么？挂起是将一种进程状态，发生在系统中进程过多，内存不足以支持的情况。OS将一部分进程调度为挂起状态：将进程映像存储到磁盘上；挂起恢复将磁盘中的对应进程的映像重新加载到内存中来
* 挂起就绪和挂起阻塞：系统调度进程为挂起态时，如果进程为就绪态，那么调度为挂起就绪态，挂起恢复时恢复为就绪态；OS也可能将阻塞的进程调度为挂起阻塞态，这取决于内存中进程的拥塞程度。同时在处于挂起态时，进程仍可以接收信号：当进程接收到阻塞事件发生时，调度对应的挂起阻塞进程为挂起就绪状态。

### 进程队列
* 每一类进程建立一个或者多个队列，队列元素为PCB
* 进程状态的改变实际上就是PCB从一个队列进入另一个队列的过程
* 就绪队列可以是一个队列，也可以是多个（优先级调度算法中，按优先级组织多个就绪队列）
* 等待队列通常按等待原因组织为多个，当进程状态由运行 -> 阻塞态时，将PCB由运行态队列出队，并按照等待原因（这将抽象为一个等待因子）链接到相应的等待队列中；运行态队列在单CPU中只有一个。

### 进程控制
* 进程控制操作：完成进程个状态之间的转换，由特定功能的原语完成。包括
* 原语：一种原子操作，完成某种特定功能的一段程序，在执行过程中不可中断，这可以通过OS禁止中断来完成。
* 进程创建原语：fork/exec CreateProcess
	* 分配PID，PCB
	* 为进程分配地址空间，虚拟地址空间，而非真正分配内存
	* 初始化PCB
	* 设置相应的队列指针：i.e.将新进程加入就绪队列中
* 进程的撤销：结束进程 exit、 TerminateProcess
	* 回收进程所占有的资源：关闭打开文件、断开网络连接、回收分配的内存等。
	* 回收PCB
* 进程阻塞 ：wait WaitForSingleObject
	* 处于运行状态的进程，在运行过程中等待某一事件发生（等待键盘输入、等待磁盘IO、等待其他进程的消息等），当该事件未发生时，该进程自己执行阻塞原语，使自己的状态变为阻塞态。

### 进程与程序
* 食谱与做菜：食谱是程序，做菜是进程
* 程序是静态的，进程是动态的

### 进程映像：对进程执行全过程的静态描述
* 用户相关：用户地址空间（代码段、数据段、堆、栈、共享库等）
* 寄存器相关：PC PSW SP IR 其他通用寄存器的值
* 内核相关：
	* 静态部分：PCB以及各种资源数据结构（打开文件列表、内存分配表、进程表等）
	* 动态部分：内核栈（不同进程在进入内核后使用不同的内核栈）。

### 上下文切换 Context Switch：一个进程下CPU进入，另一个进程被调度进入运行态
上下文切换是CPU硬件状态的切换，**那么什么是CPU的硬件状态？**实际上就是CPU运行时各寄存器的值。**如何切换？**就是CPU寄存器值得缓存和再填充。**缓存在哪里？**我们需要知道这些被缓存的CPU寄存器是对应于哪个进程的，也就是这是与进程相关的，很自然的我们将其保存在描述进程的数据结构：PCB中。

* 进程运行时，其硬件状态被保存在CPU的寄存器中：PC、PSW、SP、通用寄存器和其他控制寄存器的值。
* 进程不运行时，这些寄存器的值被保存到PCB的现场部分
* 当进程重新被调度时，将PCB中的现场部分的硬件状态推送到对应的CPU硬件寄存器中。

### 为何要引入线程
* 应用的需要
	* 常见的字处理软件一般需要的工作：处理键盘输入、实时显示与排版、定时或手动保存至磁盘、读盘等。该进程运行过程中需要这些相对独立的任务。
	* Web服务器：多线程模型
* 开销：时间空间
	* 创建和撤销
	* 线程切换：仅需要几条指令
	* 线程通信：共享一个进程的资源
* 性能：在多处理器环境下，多个CPU可以同时处理多个线程

### 线程的基本概念
在线程引入之前，进程有两个基本属性：资源拥有者、CPU调度单位。**线程继承了进程的第二个属性**，线程出现之后，进程不再是CPU的调度单位，但仍然是资源的拥有者：同一进程的不同线程之间共享进程的地址空间和其他资源。
* 描述线程：
	* 线程标识符
	* 具有状态以及状态转换
	* 不运行时需要保存上下文：PC等
	* 具有自己的栈和栈指针
* 可以创建、撤销另一个线程

### 用户级线程：Unix
* 在用户空间建立线程库，而不是通过内核支持的接口来提供管理线程的操作。这个线程库是用户（通常是高级语言例如java或者应用程序的库函数编写者）自定义的，只需要在OS上实现符合规范的线程库，就可以在不同操作系统上实现 多线程编程。
* 线程库提供了线程管理的API，还需要与线程相关的数据结构。用户级线程在实现过程中 在进程地址空间中，开辟一个运行时系统来记录和管理线程运行时状态，该进程的线程表就存储在运行时系统中。简单的说，一个进程的所有线程的运行状态在该进程对应的地址空间内。
* 内核管理的是进程，线程对内核是不可见的。在这种线程模型下，进程仍然是CPU调度的基本单位：
	* yield函数：线程只能通过“孔融让梨”来使另一个线程上CPU（线程是感知不到时钟中断的，而时钟中断这是时间片超时的基本机制）
	* 线程切换过程是由用户（应用程序）决定的，线程的调度算法自定义；切换速度快，调度灵活但应用实现繁琐。
	* 不适用于多处理器：处理器内核无法感知进程内部的线程。
	* 当一个进程的某一个线程被阻塞（大部分系统调用都会禁止中断）时，内核调度时看到的是该进程需要被阻塞，于是该进程内的所有线程都被阻塞。**解决方式：Jacketing/wrapper的方式：**该方式试图以事先检查的方式减少进程被阻塞发生的次数。在调用一个系统调用（或者其他很可能阻塞进程的操作）之前，判断是否会阻塞进程；若会，那么用户自定义地调度另一个线程上CPU。

### 核心级线程：Windows
* 内核管理所有线程，并向应用程序提供API：这个意思是说所有用户对线程的操作实际上都是内核暴露给应用的接口（**你看见的是OS内核想让你看见的😂**），也就是所有线程操作都要经过内核（由于需要经过CPU状态和堆栈切换，这会降低处理速度）。
* 内核既维护进程表又维护线程表，还要维护进程和线程的上下文。
* 内核调度以线程为基本单位。

### 混合模型：Solaris
* 创建在用户空间完成，调度等在内核完成
* 提供一种映射关系：**多路复用**来完成用户空间与内核空间相应进程的映射。在内核空间调度内核线程上CPU，对用户来说就是相应的用户进程上CPU。