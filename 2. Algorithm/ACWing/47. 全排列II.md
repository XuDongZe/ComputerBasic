### 题目描述
给定一个int数组，可以包含重复数字。返回其所有的全排列。
注意：全排列中[1,1,2]只能出现一次。

### 算法描述
* 首先我们可以使用递归来解决。每次递归地处理全排列中的第idx位(idx: 0 ~ input.size()-1 )。处理时我们认为[0, idx-1]全部得到解决（实际上就是如此，只有处理了当前位我们才进行下一次递归）
* 递归的解决全排列问题：
	* 角度一：每次递归填充 ans的一位。
	* 角度二：每次递归安排 input 的一个数字。
* 由于重点是如何解决重复数字可能造成的重复问题：那么我们采用角度二，也就是研究input的这个特定数字可以被安排到ans的哪里。显然有两种情况（该数字没有被使用的情况下）：
	* 该数字是一个重复数字：需要保持重复序列的原有顺序
	* 该数字在input中仅仅出现了一次：可以被安排到从0开始到目前ans的最后一位的任意位置。
* 如何判定该数字是一个重复数字？如何保持原有序列的顺序？
	* 将input从小到大排序，这样重复的数字在input中相邻。
	* 递归维持一个状态last，表示 上一个与当前被安排数字重复的数字在ans中出现的位置。让所有数字都在ans中last + 1的位置开始被安排。
* last的定义维持：
	* init: -1, 表示上一个重复数字在ans中出现的位置为-1， 也就是没有出现。
	* 若递归下一层要安排的数字 与 当前层安排的数字重复（经过排序之后，重复的数字安排只会出现在相邻的递归函数中。），那么last == idx（当前层安排的位置）；否则last = -1.（此时下一个被安排的数字是独一无二的）

### 复杂度分析
* 全排列的数字共有n!个，每个排列的构成需要n次递归。O(n * n!)。

### 总结
* 两种角度看全排列问题：
	* 填充ans的角度
	* 安排input的角度
* 如何判断一个可能重复的数字是独一无二的：
	* 哈希表统计次数
	* 按大小排序，那么只要该数字与前一个和后一个不重复，就是独一无二的。